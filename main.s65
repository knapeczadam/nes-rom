.include "constants.incl"

.import oam, palette
.importzp gamepad, nmi_ready, temp16bit_ptr

.segment "HEADER"
INES_MAPPER 	= 0
INES_MIRROR 	= 0
INES_RAM	= 0

.byte "NES", $1A
.byte $02 		; 16KB PRG bank count
.byte $00 		; CHR RAM (no CHR ROM)
.byte INES_MIRROR | (INES_RAM << 1) | ((INES_MAPPER & $F) << 4)
.byte INES_MAPPER & $F0
.byte $0, $0, $0, $0, $0, $0, $0, $0

.import vblank

.segment "VECTORS"
.word vblank
.word reset
.word irq

.segment "RODATA"
tiles_chr: .incbin "game.chr"

.RODATA
default_palette:
.byte $0F,$15,$26,$37
.byte $0F,$09,$19,$29
.byte $0F,$01,$11,$21
.byte $0F,$00,$10,$30
.byte $0F,$18,$28,$38
.byte $0F,$14,$24,$34
.byte $0F,$1B,$2B,$3B
.byte $0F,$12,$22,$32

welcome_txt:
.byte "HELLO WORLD", 0

.segment "CODE"
.proc copy_tiles_chr
  lda #<tiles_chr  ; load the source address into a pointer in zero page
  sta temp16bit_ptr
  lda #>tiles_chr
  sta temp16bit_ptr+1

  ldy #0       ; starting index into the first page
  sty PPU_MASK    ; Turn off rendering just in case
  sty PPU_VRAM_ADDRESS2 ; Set the destination address high byte
  sty PPU_VRAM_ADDRESS2 ; Set the destination address low byte
  ldx #32      ; number of 256-byte pages to copy
loop:
  lda (temp16bit_ptr),y  ; copy one byte
  sta PPU_VRAM_IO
  iny
  bne loop  ; repeat until we finish the page
  inc temp16bit_ptr+1  ; go to the next page
  dex
  bne loop  ; repeat until we've copied enough pages
  rts
.endproc

.CODE
irq:
	rti

.proc reset
	sei 			; disable interrupts
	lda #0
	sta PPU_CONTROL
	sta PPU_MASK
	sta APU_DM_CONTROL
	lda #$40
	sta JOYPAD2

	; Disable decimal mode
	cld
	ldx #$FF
	txs

	; Wait for V-Blank
	bit PPU_STATUS
wait_vblank:
	bit PPU_STATUS
	bpl wait_vblank

	lda #0
	ldx #0
clear_ram:
	sta $0000, x
	sta $0100, x
	sta $0200, x
	sta $0300, x
	sta $0400, x
	sta $0500, x
	sta $0600, x
	sta $0700, x
	inx
	bne clear_ram

	lda #$FF
	ldx #0
clear_oam:
	sta oam, x
	inx
	inx
	inx
	inx
	bne clear_oam

wait_vblank2:
	bit PPU_STATUS
	bpl wait_vblank2

    ; Copy CHR tiles into CHR RAM
	jsr copy_tiles_chr

	; Enable V-Blank
	lda #%10001000
	sta PPU_CONTROL

	jmp main
.endproc

.proc ppu_signal
	sta nmi_ready

loop:
	lda nmi_ready
	bne loop

	rts
.endproc

.proc ppu_update
	lda #NMI_SIG_RENDERING_ON
	
	jmp ppu_signal
.endproc

.proc ppu_off
	lda #NMI_SIG_RENDERING_OFF

	jmp ppu_signal
.endproc

.proc clear_nametable
	lda PPU_STATUS

	; Set PPU address to first nametable address
	lda #>PPU_ADDR_NT_0
	sta PPU_VRAM_ADDRESS2
	lda #<PPU_ADDR_NT_0
	sta PPU_VRAM_ADDRESS2

	; Clear the name table
	lda #0
	ldy #30
row_loop:
	ldx #32

col_loop:
	sta PPU_VRAM_IO
	dex
	bne col_loop

	dey
	bne row_loop

	; Clear attribute table
	ldx #64
loop:
	sta PPU_VRAM_IO
	dex
	bne loop

	rts
.endproc

.proc gamepad_poll
	; Prepare for read
	lda #1
	sta JOYPAD1
	lda #0
	sta JOYPAD1

	ldx #8
loop:
	pha
	lda JOYPAD1

	and #%00000011
	cmp #%00000001
	pla

	ror
	dex
	bne loop
	sta gamepad
	rts
.endproc

.proc main
	ldx #0

paletteloop:
	lda default_palette, x
	sta palette, x
	inx
	cpx #32
	bcc paletteloop

	jsr clear_nametable

	lda PPU_STATUS
	lda #>PPU_ADDR_NT_0
	sta PPU_VRAM_ADDRESS2
	lda #<PPU_ADDR_NT_0
	sta PPU_VRAM_ADDRESS2

	ldx #0
text_loop:
	lda welcome_txt, x
	sta PPU_VRAM_IO
	inx
	cmp #0 ; stop at null terminator
	beq :+
	jmp text_loop
:
	
	;lda #180
	;sta oam
	;lda #120
	;sta oam + 3
	;lda #1
	;sta oam + 1
	;lda #0
	;sta oam + 2
	jsr ppu_update

main_loop:
	lda nmi_ready
	; cmp #0 unnecessary because lda already sets this flag based on the value
	bne main_loop

	lda #1
	sta nmi_ready
	jmp main_loop
.endproc

; .out .sprintf("%d", * - irq)

